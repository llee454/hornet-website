<!DOCTYPE html>
<!-- set mustache tag delimiters {{=[[ ]]=}} -->
<html lang="en">
  <head>
    <title>Larry Lee: Programmer</title>
    <meta name="viewport" content="initial-scale = 1.0,maximum-scale = 1.0" http-equiv="Content-Type">
    <link rel="icon" type="image/png" href="images/favicon.png">

    <!-- Import Libraries -->
    <script src="lib/async/dist/async.js"></script>
    <script src="lib/jquery/jquery.js"></script>
    <script src="lib/jquery-getCSS/jquery.getCSS.js"></script>
    <script src="lib/jquery-ui/jquery-ui.js"></script>
    <script src="lib/jq-ajax-progress/src/jq-ajax-progress.js"></script>
    <script src="lib/uri/uri.js"></script> 
    <script src="lib/qunit/qunit.js"></script>
    <script>
      QUnit.config.autostart = false;
    </script>
 
    <!-- Load the library stylesheets -->
    <link rel="stylesheet" type="text/css" href="lib/jquery-ui/jquery-ui.min.css">

     <!-- Load the current theme's stylesheet -->
    <link rel="stylesheet" type="text/css" href="themes/portfolio/portfolio.css">

    <!-- Load the module libraries -->
    <script src="modules/coq/lib/node_modules/jscoq/ui-js/jscoq-loader.js"></script>

    <!-- Load the experimental Progressbar module -->                                                |~                                                                                                        
    <script src="modules/progressbar/progressbar.js"></script>

    <!-- Load the Core Module -->
    <script src="modules/core/core.js"></script>
  </head>
  <body id="top">
    <div id='header'>
      <div id='header-content'>
        <div id='header-menu-container'>
          <div id='header-menu'>
            <a class='menu-item header-menu-item' href='##case-study'>CASE STUDY</a>
            <a class='menu-item header-menu-item' href='##samples'>WORK SAMPLES</a>
            <a class='menu-item header-menu-item' href='data/resume with cover letter.pdf'>RESUME</a>
            <a class='menu-item header-menu-item' href='##endorsements'>REFERENCES</a>
            <a class='menu-item header-menu-item' href='##contact'>CONTACT</a>
          </div>
        </div>
      </div>
    </div>
    <div id='mobile-menu'>
      <div id='mobile-menu-header'>MENU</div>
      <div id='mobile-menu-content'>
        <a class='menu-item mobile-menu-item' href='##case-study'>CASE STUDY</a>
        <a class='menu-item mobile-menu-item' href='##samples'>WORK SAMPLES</a>
        <a class='menu-item mobile-menu-item' href='data/resume with cover letter.pdf'>RESUME</a>
        <a class='menu-item mobile-menu-item' href='##endorsements'>REFERENCES</a>
        <a class='menu-item mobile-menu-item' href='##contact'>CONTACT</a>
      </div>
    </div>
    <div id='hero'>
      <div id='hero-overlay'>
        <div id='hero-overlay-content'>
          <h1>Proven Ability &#8718;</h1>
          <p>
            My name is <strong>Larry Lee</strong> and I am a software developer specializing in formal methods.
            My work includes formally verified hardware designs and real-world examples of applied mathematics.
          </p>
        </div>
      </div>
      <div id='hero-video-container'>
        <video id='hero-video' class="video-js vjs-default-skin" muted loop autoplay preload="auto">
          <source src="https://work-website-media.s3.us-east-2.amazonaws.com/background+loop.mp4"/>
        </video>
      </div>
    </div>
    <div id='body'>
      <div id='main-content'>
        <!-- intro section -->
        <div id='intro' class='section light-section'>
          <div class='section-content'>
            <div id='assertion' class='section-header'>
              <h1><span class='section-start-icon'>&#8718;</span><br/>I am a software developer specializing in formal methods.</h1>
            </div>
            <div class='section-body'>
              <p>
                Formally Verified Software development is the practice of writing mathematical proofs to verify software.
                I specialize in using <strong>Coq</strong> to do this.
                Over the last 7 years, I've written <strong>hundreds</strong> of proofs using Coq and have developed formally verified algorithms.
                I've contributed to the Coq Standard Library and am a package maintainer in the Coq Package Index.
                My portfolio demonstrates my ability to analyze complex problems and produce results.
              </p>
              <div class="video_player_block">
                <video id="intro-video" class="video-js vjs-default-skin" poster="images/hero_video_poster.jpeg" controls preload="auto">
                  <source src="https://work-website-media.s3.us-east-2.amazonaws.com/success+story+second+version.mp4"/>
                </video>
              </div>
            </div>
          </div>
        </div>
        <!-- success story -->
        <div id='case-study' class='section light-section'>
          <div class='section-content'>
            <div class='section-header'>
              <h1><span class='section-start-icon'>&#8718;</span><br/>Industrial Results</h1>
            </div>
            <div class='section-body'>
              <p>SiFive is a Silicon Valley-based company specializing in the design of RISC-V processors.</p>
              <p>
                In 2018, they suspected that a register used within the floating point unit of their S-series processors was too small to store the intermediate values that it computed during square root and division operations.
                While the unit passed SiFive's test suite, They feared that a bug lurked in an edge case not covered by their tests.
              </p>
              <p>
                I successfully derived an analytical proof verifying that the registers allocated by the unit where sufficiently large to store these intermediate values.
                More importantly, I formalized this proof using Coq; thereby giving SiFive the assurance that they needed to move forward with production.
              </p>
              <p>
                You can view the formalized Coq version of this proof here: <a href="https://github.com/llee454/FPU-Verification/blob/master/sqrt_rem_proof.md">FPU-Verification</a>
              </p>
              <div id='case-study-details' class="accordion_block">
                <div class="accordion_item_block">
                  <div class="accordion_item_number">1</div>
                  <div class="accordion_item_title">Introduction</div>
                  <div class="accordion_item_body">
                    <p>
                      SiFive had developed the unit in a modeling language named Chisel.
                      I began by writing a set of recurrence relations that formalized the square root and division algorithms.
                      I then identified bijective mappings between the variables used in SiFive's model and the variables used in my equations.
                      This allowed me to prove that my equations correctly modeled the unit.
                      I then verified that my equations correctly converged onto the correct results, thereby verifying that SiFive's unit was logically correct.
                    </p>
                    <p>
                      One problem remained however.
                      SiFive's unit defined a register named \(rem\), and they feared that this register was too small to store all of the intermediate values computed during operation.
                      To prove that the \(rem\) register was large enough, I needed to prove that the values stored within \(rem\) were smaller than \(2^w\), where \(w\) represented the number of bits SiFive had allocated.
                    </p>
                    <p>
                      This register corresponded to a variable defined within my equations named \(error(n)\).
                      Using the mapping between \(rem\) and \(error(n)\), I had to verify that: $$\forall n, error(n) &lt; \frac{8}{2^n}$$ when computing the square root of an odd number, and an analogous result when computing the square root of even numbers.
                      The following is an extract of my proof of this result.
                    </p>
                  </div>
                </div>
                <div class="accordion_item_block">
                  <div class="accordion_item_number">2</div>
                  <div class="accordion_item_title">The Model</div>
                  <div class="accordion_item_body">
                    <p>
                      Let \(x\) denote the number that the floating point unit is computing the square root for.
                      Let \(approx(n)\) denote the \(n^{th}\) approximation of the square root of \(x\).
                      And, let \(error(n)\) represent the \(n^{th}\) approximation error.
                      Then \(x\) is given by:
                    </p>
                    [[#eqn]]1: $$x = approx (n)^2 + error (n)$$[[/eqn]]
                    <p>Setting \(approx(0) = 0\), we will append a bit, \(b(n)\), onto the approximation at the end of each iteration.</p>
                    [[#eqn]]2: $$\begin{array}{rcl} approx (0) &amp;=&amp; 0 \\ \\ approx (n + 1) &amp;=&amp; approx (n) + \frac{b (n)}{2^n}\end{array}$$[[/eqn]]
                    <p>where:</p>
                    [[#eqn]]4: $$b(n) = \begin{cases} 1, &amp; \mbox{if } \frac{1}{2^n} (2\ approx (n) + \frac{1}{2^n}) \le error (n) \\ \\ 0, &amp; \mbox{otherwise}\end{cases}$$[[/eqn]]
                    <p>Using back substitution we can solve for \(error\) to derive the following recurrence relation:</p>
                    [[#eqn]]5: $$\begin{array}{rcl} error (0) &amp;=&amp; x \\ \\ error (n + 1) &amp;=&amp; error (n) - \frac{b (n)}{2^n} (2\ approx (n) + \frac{b (n)}{2^n})\end{array}$$[[/eqn]]
                    <p>Using the above equations and the fact that \(1 &lt;= x &lt; 2\), we can derive the following corollaries:</p>
                    [[#eqn]]6: $$\forall n, 0 \le approx(n) \lt 2$$[[/eqn]]
                    [[#eqn]]7: $$\begin{array}{rcl} \forall n, b (n) = 0 \implies error (n) \lt \frac{1}{2^n} (2\ approx (n) + \frac{1}{2^n}) \\ \\ \forall n, b (n) = 1 \implies \frac{1}{2^n} (2\ approx (n) + \frac{1}{2^n}) \le error (n) \end{array}$$[[/eqn]]
                  </div>
                </div>
                <div class="accordion_item_block">
                  <div class="accordion_item_number">3</div>
                  <div class="accordion_item_title">A Lower Bound for \(approx\)</div>
                  <div class="accordion_item_body">
                    <div class="eqn-labeled">
                      $$\mbox{Lemma 1.1:}\quad \forall n, x \lt (approx (n) + \frac{2}{2^n})^2$$
                    </div>
                    <p><strong>Proof</strong></p>
                    <p>We proceed using a proof by induction. When n = 0, substitution gives:</p>
                    [[#eqn]]8: $$\begin{array}{rcl} x &amp;\lt&amp; (approx (0) + \frac{2}{2^0})^2 \\ x &amp;\lt&amp; 4\end{array}$$[[/eqn]]
                    <p>When \(n \gt 0\), we have to prove:</p>
                    [[#eqn]]9: $$\begin{array}{l} \forall n, &amp;x \lt (approx (n) + \frac{2}{2^n})^2 \implies \\ &amp;x \lt (approx (n + 1) + \frac{1}{2^n})^2.\end{array}$$[[/eqn]]
                    <p>We proceed by case analysis. \(b (n)\) equals either 0 or 1.</p>
                    <p><strong><code>b (n) = 0</code></strong><p>
                    <p>When \(b (n) = 0\), our goal becomes: \(x \lt (approx (n) + \frac{1}{2^n})^2\). Expanding and rewriting \(error\) using (7) leads to:</p>
                    <div class="eqn-labeled">
                      $$\begin{array}{rcl}<!--
                        -->x &amp;=&amp; approx (n)^2 + error (n) \\<!--
                        -->x &amp;\lt&amp; approx (n)^2 + \frac{1}{2^n} (2\ approx (n) + \frac{1}{2^n}) \quad \quad \mbox{by (7)} \\<!--
                        -->x &amp;\lt&amp; (approx (n) + \frac{1}{2^n})^2<!--
                      -->\end{array}$$
                    </div>
                    <p><strong><code>b (n) = 1</code></strong><p>
                    <p>
                      When \(b (n) = 1\), our goal becomes: \(x \lt (approx (n) + \frac{1}{2^n} + \frac{1}{2^n})^2\).
                      However, this is equivalent to: \(a \lt (approx (n) + \frac{2}{2^n})^2\), which is identical to our inductive hypothesis.
                      &#8718;
                    </p>
                  </div>
                </div>
                <div class="accordion_item_block">
                  <div class="accordion_item_number">4</div>
                  <div class="accordion_item_title">A Constant Upper Bound for \(error\)</div>
                  <div class="accordion_item_body">
                    <div class="eqn-labeled">
                      $$\mbox{Lemma 1.2:}\quad \forall n, error (n) \lt 4$$
                    </div>
                    <p><strong>Proof</strong></p>
                    <p>We proceed using proof by induction.</p>
                    <p><strong><code>n = 0</code></strong><p>
                    <p>When \(n = 0\), the lemma follows immediately from (5): \(error (0) = x \lt 2\).</p>
                    <p><strong><code>n &ge; 1</code></strong><p>
                    <p>
                      When \(n \ge 1\), our goal becomes: \(error (n) \lt 4 \implies\)\(error (n + 1) \lt 4\).
                      Assuming that \(error (n) \lt 4\) and expanding \(error (n + 1)\) leads to:
                    </p>
                    <div class="eqn-labeled">
                      $$\begin{array}{rcl}<!--
                        -->error (n + 1) &amp;=&amp; error (n) - \frac{b (n)}{2^n} (2\ approx (n) + \frac{b (n)}{2^n}) \\<!--
                        -->error (n + 1) &amp;\lt&amp; 4 - \frac{b (n)}{2^n} (2\ approx (n) + \frac{b (n)}{2^n}) \qquad \mbox{by the ind. hyp.} \\<!--
                        -->error (n + 1) &amp;\lt&amp; 4 - 0 \\<!--
                      -->\end{array}$$
                    </div>
                    <p>
                      Where we maximized the rhs in the last inequality by taking the case where \(b (n) = 0\).  
                      &#8718;
                    </p>
                  </div>
                </div>
                <div class="accordion_item_block">
                  <div class="accordion_item_number">5</div>
                  <div class="accordion_item_title">A Scaling Upper Bound for \(error\)</div>
                  <div class="accordion_item_body">
                    <div class="eqn-labeled">
                      $$\mbox{Lemma 1.3:}\quad \forall n, x \lt (approx (n) + \frac{2}{2^n})^2$$
                    </div>
                    <p><strong>Proof</strong></p>
                    <p>
                      We will proceed by induction over \(n\).
                      When \(n = 0\), Lemma 1.3 follows immediately as \((approx (0) + \frac{2}{2^0})^2 = 4\) and \(x \lt 2\).
                      When \(n \ge 1\), our goal becomes: \(x \lt (approx (n) + \frac{2}{2^n})^2 \implies\)\(x \lt (approx (n + 1) + \frac {2}{2^{n + 1}})^2\).
                      Unfolding \(approx (n + 1)\), reduces our goal to: \(x \lt (approx (n) + \frac{b (n)}{2^n} + \frac{1}{2^n})^2\).
                    </p>
                    <p><strong><code>b (n) = 0</code></strong><p>
                    <p>When \(b (n) = 0\) our goal follows algebraicly:</p>
                    <div class="eqn-labeled">
                      $$\begin{array}{rcl}<!--
                        -->x &amp;=&amp; approx (n)^2 + error (n)\\<!--
                        -->&amp;\lt&amp; approx (n)^2 + \frac{1}{2^n} (2\ approx (n) + \frac{1}{2^n}) \qquad \mbox {by (7)}\\<!--
                        -->&amp;\lt&amp; (approx (n) + \frac{1}{2^n})^2\\<!--
                      -->\end{array}$$
                    </div>
                    <p><strong><code>b (n) = 1</code></strong><p>
                    <p> 
                      When \(b (n) = 1\) our goal equals the inductive hypothesis.
                      &#8718;
                    </p>
                    <hr/>
                    <div class="eqn-labeled">
                      $$\mbox{Corollary 1.4:}\quad \forall n, error (n) \lt \frac{4}{2^n} (approx (n) + \frac{1}{2^n})$$
                    </div>
                    <p><strong>Derivation</strong></p>
                    <p>Corollary 1.4 follows algebraicly from Lemma 1.3:</p>
                    <div class="eqn-labeled">
                      $$\begin{array}{rcl}<!--
                        -->x &amp;\lt&amp; (approx (n) + \frac{2}{2^n})^2 \\<!--
                        -->x &amp;\lt&amp; approx (n)^2 + \frac{4}{2^n} (approx (n) + \frac{1}{2^n}) \\<!--
                        -->x - approx (n)^2 &amp;\lt&amp; \frac{4}{2^n} (approx (n) + \frac{1}{2^n}) \\<!--
                        -->error (n) &amp;\lt&amp; \frac{4}{2^n} (approx (n) + \frac{1}{2^n})<!--
                      -->\end{array}$$
                    </div>
                  </div>
                </div>
                <div class="accordion_item_block">
                  <div class="accordion_item_number">6</div>
                  <div class="accordion_item_title">Conclusion</div>
                  <div class="accordion_item_body">
                    <div class="eqn-labeled">
                      $$\mbox{Theorem 1.5:}\quad \forall n, error (n) \lt \frac{8}{2^n}$$
                    </div>
                    <p><strong>Proof</strong></p>
                    <p>
                      We will proceed using induction over \(n\).
                      When \(n = 0\), \(error (0) = x \lt 2\) and Theorem 1.5 follows immediately.
                      Hence, we only need to consider the case where \(n \ge 1\).
                    </p>
                    <p>Observe that:</p>
                    <div class="eqn-labeled">
                      $$\begin{array}{rcl}<!--
                        -->approx (n)^2 &amp;=&amp; x - error (n) \\<!--
                        -->approx (n)^2 &amp;\lt&amp; 2 - 0 \qquad \mbox{using (6)} \\<!--
                        -->approx (n) &amp;\lt&amp; \sqrt {2}<!--
                      -->\end{array}$$
                    </div>
                    <p>
                      We can substitute this upper bound into the scaling upper bound we derived in Corollary 1.4.
                      Doing so leads to:
                    </p>
                    <div class="eqn-labeled">
                      $$\begin{array}{rcl}<!--
                        -->error (n) &amp;\lt&amp; \frac{4}{2^n} (approx (n) + \frac{1}{2^n}) \\<!--
                        -->error (n) &amp;\lt&amp; \frac{4}{2^n} (\sqrt {2} + \frac{1}{2^n})<!--
                      -->\end{array}$$
                    </div>
                    <p>
                      which is always less than \(\frac{8}{2^n}\) when \(n \ge 1\).
                      This observation completes this proof.
                      &#8718;
                    </p>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        <!-- portfolio -->
        <div id='portfolio' class='section dark-section'>
          <div id='portfolio-parallax-background'></div>
          <div id='portfolio-parallax-background-overlay'></div>
          <div class='section-content-padding'>
            <div class='section-content'>
              <div class='section-header'>
                <h1><span class='section-start-icon'>&#8718;</span><br/>Large Scale Developments</h1>
              </div>
              <div class='section-body'>
                <p>While working with SiFive, I was the lead developer for Kami Processor, an Open-Source RISC-V processor written in Kami.</p>
                <p>Kami is a domain-specific language embedded within Gallina designed for modeling digital circuits.</p>
                <p>Kami Processor is a highly configurable RISC-V processor that implements a substantial fraction of the RISC-V feature set: including memory virtualization, compressed instruction encodings, floating point operations, and dynamic data widths.</p>
                <p>As part of this work, I verified components used within Kami Processor and verified many of the Gallina functions used to generate the model.</p>
                <ul class='links'>
                  <li><a href='data/kami_proc_report.pdf'>Kami Processor: Status and Comparison</a></li>
                </ul>
                <div id='portfolio-details' class="accordion_block">
                  <div class="accordion_item_block">
                    <div class="accordion_item_number">1</div>
                    <div class="accordion_item_title">Kami Processor</div>
                    <div class="accordion_item_body">
                      <h2>Overview</h2>
                      <p>SiFive started the Kami Processor project in 2018 intending to develop a canonical model of the RISC-V specification. While working at SiFive, I was the primary developer for Kami Processor.</p>
                      <p>The Kami processor supports the following RISC-V extensions: I, M, A, D, F, C, S, U, Zifencei, and Zcsr. This means that the Kami processor supports the mandatory core set of integer arithmetic and logic instructions prescribed by the RISC-V ISA (I). In addition, it supports integer multiplication (M), atomic memory operations (A), 64 bit floating point operations (D), 32 bit floating pointoperations (F), compressed instruction encodings (C), multi threaded synchronization support (ZiFencei), and support for RISC-V's control status register operations (Zicsr).</p>
                      <p>The Kami Processor includes a page table walker which allows applications to translate between physical and virtual memory addresses. Kami Processor includes a translation look-aside buffer that caches address translations in a buffer that uses a pseudo-LRU allocation algorithm.</p>
                      <p>The RISC-V spec defines several virtual memory modes. These are denoted by a code that indicates the size of the words used to encode virtual addresses. For example, "sv39" indicates that the virtual addresses are 39 bits wide. The Kami Processor supports virtual address modes sv32, sv39, and sv48.</p>
                      <p>The RISC-V memory protection model prescribes a physical memory protection scheme based around physical protection control status registers (PMP CSRs). The Kami Processor supports the full suite of PMP CSRs and all of the RISC-V address matching schemes, namely: top of range (TOR), naturally aligned four-byte regions (NA4), and naturally aligned power of two regions (NAPOT). Its address granularity is configurable.</p>
                      <p>I wrote the Kami Processor to use the TileLink interchip communication protocol. The TileLink protocol defines a set of conformance levels. Kami Processor's device interface communicates using the TileLink Uncached Heavyweight (TL-UH) message protocol. This protocol extends the basic read and write messages provided by the TileLink Uncached Lightweight (TL-UL) message protocol by adding atomic memory operations. By supporting the TileLink protocol, the Kami Processor can be integrated into systems using a number of interchip bus protocols either directly or through a conversion bridge.</p>
                    </div>
                  </div>
                  <div class="accordion_item_block">
                    <div class="accordion_item_number">2</div>
                    <div class="accordion_item_title">Kami</div>
                    <div class="accordion_item_body">
                      <h2>Overview</h2>
                      <p>Kami is a modeling language intended to model digital circuits. Its language syntax and semantics are derived from BlueSpec. It is a domain-specific language embedded withing Gallina, Coq's dependently typed programming language. Kami uses Gallina's dependent types to specify component properties. Kami verifies that these component properties are true using mathematical proofs expressed in Coq's Ltac and Gallina. Ltac is a macro language that Coq interprets to generate Gallina terms. These Gallina terms represent mathematical proofs.</p>
                      <P>A Kami model of a synchronous digital circuit consists of one or more Kami modules and a scheduler. A Kami module comprises a set of registers, rules, and methods. A rule represents a combinatorial circuit that the scheduler tries to execute as frequently as possible. A method is a combinatorial circuit that posses a well defined set of inputs and outputs and which may be shared between circuits provided by other modules. Both rules and methods consist of Kami actions. A Kami action is a combinatorial circuit that may read or write to one or more registers and which may "call" one or more methods. Kami actions consist of a series of Kami expressions, which are combinatorial circuits that do not write to registers or call methods, and Kami statements that read and write to registers and call methods.</p>
                      <h2>The Utila Library</h2>
                      <p>I wrote the Utila library, which defines a set of formally verified hardware components that are used throughout Kami Processor.</p>
                      <p>The library includes formally verified lookup tables, and useful circuit combinators.</p>
                    </div>
                  </div>
                  <div class="accordion_item_block">
                    <div class="accordion_item_number">3</div>
                    <div class="accordion_item_title">RISC-V</div>
                    <div class="accordion_item_body">
                      <h2>Overview</h2>
                      <p>RISC-V is an open instruction set architecture (ISA) originally developed atBerkley and Stanford.</p>
                      <p>As the name indicates, RISC-V is a reduced instruction set computer architec-ture.</p>
                      <p>Following the philosophy of other RISC architectures, RISC-V defines a small set of core processor instructions while eschewing the more complicated instructions provided by traditional complex instruction set computer (CISC) architectures.</p>
                      <p>RISC-V was designed to be an extensible RISC architecture. It includes provisions for adding specialized complex instructions and for standardizing sets of instructions critical to common applications.</p>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        <!-- sample work -->
        <div id='samples' class='section light-section'>
          <div class='section-content'>
            <div class='section-header'>
              <h1><span class='section-start-icon'>&#8718;</span><br/>Interactive Code Sample</h1>
            </div>
            <div class='section-body'>
              <p>
                The example below presents a Gallina function that accepts a number and returns an equivalent string.
                This example includes a proof that the given function is injective.
                Whereas the print function provided by the Coq Standard Library only supports decimal and hexadecimal formats, the example presented below can support an arbitrary radix.
                Furthermore, this example demonstrates a number of Coq design patterns, including well founded recursion, structural recursion, and dependent types.
              </p>
              <p>
                This example was originally defined as part of the Kami project: <a href="https://github.com/sifive/Kami/blob/master/Lib/NatStr.v">NatStr.v</a>.
              </p>
              <div id='code-sample'>
                <div class='coq_block'>modules/coq/examples/nat_str.v</div>
              </div>
            </div>
          </div>
        </div>
        <!-- open source contributions -->
        <div id='contributions' class='section light-section'>
          <div class='section-content'>
            <div class='section-header'>
              <h1><span class='section-start-icon'>&#8718;</span><br/>Open Source Contributions</h1>
            </div>
            <div class='section-body'>
              <p>Over the years, I've contributed to the Coq Standard Library and released packages through the Coq Package Index.</p>
              <p>The Coq package index is a curated collection of Coq modules that are released by the Coq maintainers as part of the Coq Opam repository.</p>
              <p>I am the package maintainer for two CPI libraries: functional algebra and pigeons.</p>
              <ul class='links'>
                <li><a href='https://github.com/llee454/functional-algebra'>Functional Algebra: a formalization of abstract algebra</a></li>
                <li><a href='https://github.com/llee454/pigeons'>Pigeons: a sample proof of the Pigeonhole Principle</a></li>
              </ul>
            </div>
          </div>
        </div>
        <div id='endorsements' class='section light-section'>
          <div class='section-content'>
            <div class='section-header'>
              <h1><span class='section-start-icon'>&#8718;</span><br/>Endorsements</h1>
            </div>
            <div class='section-body'>
              [[#endorsements?]]
                <div class='endorsement'>
                  <div class='endorsement-quote'>
                    <p>"[[endorsement-quote]]"</p>
                  </div>
                  <div class='endorsement-author'>
                    <div class='endorsement-author-name'>[[endorsement-name]]</div>
                    <div class='endorsement-author-title'>[[endorsement-title]]</div>
                    <div class='endorsement-author-email'>[[endorsement-email]]</div>
                  </div>
                  <div class='clear-float'></div>
                </div>
              [[/endorsements?]]
            </div>
          </div>
        </div>
        <div id='qed-section' class='section light-section'>
          <div class='section-content'>
            <div class='section-body'>
              <div id='qed'><strong>\(\mbox {Q.E.D}\)</strong></div>
            </div>
          </div>
        </div>
        <!-- contact -->
        <div id='contact' class='dark-section section'>
          <div class='section-content'>
            <div class='section-header'>
              <h1>Send Me a Message</h1>
            </div>
            <div class='section-body'>
              <ul>
                <li><span class='contact-label'>email:</span><a href="mailto:llee454@gmail.com">llee454@gmail.com</a></li>
                <li><span class='contact-label'>github:</span><a href="https://github.com/llee454">https://github.com/llee454</a></li>
              </ul>
              <div class="form_block">feedback_form</div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div id="back_to_top"><a href="#">Back To Top</a></div>
    <div id="footer"></div>
  </body>
</html>
