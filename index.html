<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Larry Lee: Programmer</title>
    <meta name="viewport" content="initial-scale = 1.0,maximum-scale = 1.0" http-equiv="Content-Type">
    <link rel="icon" type="image/png" href="images/favicon.png">

    <!-- Import Libraries -->
    <script src="lib/async/dist/async.js"></script>
    <script src="lib/jquery/jquery.js"></script>
    <script src="lib/jquery-getCSS/jquery.getCSS.js"></script>
    <script src="lib/jquery-ui/jquery-ui.js"></script>
    <script src="lib/jq-ajax-progress/src/jq-ajax-progress.js"></script>
    <script src="lib/uri/uri.js"></script> 
    <script src="lib/qunit/qunit.js"></script>
    <script>
      QUnit.config.autostart = false;
    </script>
 
    <!-- Load the library stylesheets -->
    <link rel="stylesheet" type="text/css" href="lib/jquery-ui/jquery-ui.min.css">

     <!-- Load the current theme's stylesheet -->
    <link rel="stylesheet" type="text/css" href="themes/portfolio/portfolio.css">

    <!-- Load the experimental Progressbar module -->
    <script src="modules/progressbar/progressbar.js"></script>

    <script src="lib/uri/uri.js"></script>
    <script src="lib/qunit/qunit.js"></script>
    <script>
      QUnit.config.autostart = false;
    </script>

    <!-- Load the current theme's stylesheet -->
    <link rel="stylesheet" type="text/css" href="themes/portfolio/portfolio.css">

    <!-- Load the module libraries -->
    <script src="modules/coq/lib/node_modules/jscoq/ui-js/jscoq-loader.js"></script>

    <!-- Load the Core Module -->
    <script src="modules/core/core.js"></script>
  </head>
  <body id="top">
    <div id='header'>
      <div id='header-content'>
        <div id='header-menu-container'>
          <div id='header-menu'>
            <a class='menu-item header-menu-item' href='##case-study'>CASE STUDY</a>
            <a class='menu-item header-menu-item' href='##samples'>WORK SAMPLES</a>
            <a class='menu-item header-menu-item' href='data/resume with cover letter.pdf'>RESUME</a>
            <a class='menu-item header-menu-item' href='##contact'>CONTACT</a>
          </div>
        </div>
      </div>
    </div>
    <div id='mobile-menu'>
      <div id='mobile-menu-header'>MENU</div>
      <div id='mobile-menu-content'>
        <a class='menu-item mobile-menu-item' href='##case-study'>CASE STUDY</a>
        <a class='menu-item mobile-menu-item' href='##samples'>WORK SAMPLES</a>
        <a class='menu-item mobile-menu-item' href='data/resume with cover letter.pdf'>RESUME</a>
        <a class='menu-item mobile-menu-item' href='##contact'>CONTACT</a>
      </div>
    </div>
    <div id='hero'>
      <div id='hero-overlay'>
        <div id='hero-overlay-content'>
          <h1>Proven Ability &#8718;</h1>
          <p>
            My name is Larry Lee, I am a software developer specializing in formal methods.
            My work includes formally verified hardware designs and real-world examples of applied mathematics.
          </p>
        </div>
      </div>
      <div id='hero-video-container'>
        <video id='hero-video' class="video-js vjs-default-skin" muted loop autoplay preload="auto">
          <source src="https://work-website-media.s3.us-east-2.amazonaws.com/background+loop.mp4"/>
        </video>
      </div>
    </div>
    <div id='body'>
      <div id='main-content'>
        <!-- intro section -->
        <div id='intro' class='section'>
          <div class='section-content'>
            <div id='assertion' class='section-header'>
              <h1>I am a software developer specializing in formal methods.</h1>
            </div>
            <div class='section-body'>
              <p>Formally Verified Software development is the practice of writing mathematical proofs to verify software.
                I specialize in using <strong>Coq</strong> to do this.
                Over the last 7 years, I've proved <strong>hundreds</strong> of results using Coq and have developed formally verified algorithms.
                I've contributed to the Coq Standard Library and am a package maintainer in the Coq Package index.
                My portfolio of results proves my ability to analyze complex problems and produce results.
              </p>
              <div class="video_player_block">
                <video id="intro-video" class="video-js vjs-default-skin" poster="images/hero_video_poster.jpeg" controls preload="auto">
                  <source src="https://work-website-media.s3.us-east-2.amazonaws.com/success+story+second+version.mp4"/>
                </video>
              </div>
            </div>
          </div>
        </div>
        <!-- definition -->
        <div id='definition' class='section'>
          <div class='section-content'>
            <div class='section-header'>
              <h1>Definition: What is Formally Verified Software Development?</h1>
            </div>
            <div class='section-body'>
              <p>Formally verified software development is the practice of writing mathematical proofs to verify that software is correct.</p>
              <p>A mathematical proof is a sequence of assertions in which every assertion is either an axiom or can be derived from one or more of the preceding assertions by applying a logical deduction rule.</p>
              <p>I specialize in writing proofs in Coq, a programming language capable of expressing both logical arguments and describing algorithms.</p>
            </div>
          </div>
        </div>
        <!-- success story -->
        <div id='case-study' class='section'>
          <div class='section-content'>
            <div class='section-header'>
              <h1>Industrial Results</h1>
            </div>
            <div class='section-body'>
              <p>In 2018, SiFive, a Silicon Valley-based company specializing in the design of RISC-V processors used an algorithm that they feared was incorrect.</p>
              <p>
                They suspected that a register used within the floating point unit of their S-series processors was too small to store the intermediate values that it computed during square root and division operations.</p>
                While the unit passed SiFive's test suite, They feared that a bug lurked in an edge case not covered by their tests.
              </p>
              <p>
                I successfully derived an analytical proof verifying that the registers allocated by the unit where sufficiently large to store these intermediate values.
                More importantly, I formalized this proof using Coq; thereby giving SiFive the assurance that they needed to move forward with production.
              </p>
              <p>
                You can view the formalized Coq version of this proof here: <a href="https://github.com/llee454/FPU-Verification/blob/master/sqrt_rem_proof.md">FPU-Verification</a>
              </p>
              <div class="accordion_block">
                <div class="accordion_item_block">
                  <div class="accordion_item_number">1</div>
                  <div class="accordion_item_title">Introduction</div>
                  <div class="accordion_item_body">
                    <p>
                      SiFive had developed the unit in a modeling language named Chisel.
                      I began by writing a set of recurrence relations that formalized the square root and division algorithms.
                      I then identified bijective mappings between the variables used in SiFive's model and the variables used in my equations.
                      This allowed me to prove that my equations correctly modeled the unit.
                      I then verified that my equations correctly converged onto the correct results, thereby verifying that SiFive's unit was logically correct.
                    </p>
                    <p>
                      One problem remained however.
                      SiFive's unit defined a register named \(rem\), and they feared that this register was too small to store all of the intermediate values computed during operation.
                      To prove that the \(rem\) register was large enough, I needed to prove that the values stored within \(rem\) were smaller than \(2^w\), where \(w\) represented the number of bits SiFive had allocated.
                    </p>
                    <p>
                      This register corresponded to a variable defined within my equations named \(error(n)\).
                      Using the mapping between \(rem\) and \(error(n)\), I had to verify that: $$\forall n, error(n) &lt; \frac{8}{2^n}$$ when computing the square root of an odd number, and an analogous result when computing the square root of even numbers.
                      The following is an extract of my proof of this result.
                    </p>
                  </div>
                </div>
                <div class="accordion_item_block">
                  <div class="accordion_item_number">2</div>
                  <div class="accordion_item_title">The Model</div>
                  <div class="accordion_item_body">
                    <p>
                      Let \(x\) denote the number that the floating point unit is computing the square root for.
                      Let \(approx(n)\) denote the \(n^{th}\) approximation of the square root of \(x\).
                      And, let \(error(n)\) represent the \(n^{th}\) approximation error.
                      Then \(x\) is given by:
                    </p>
                    <div class="curly_block">{{#eqn.labeled}}1: $$x = approx (n)^2 + error (n)$${{/eqn.labeled}}</div>
                    <p>Setting \(approx(0) = 0\), we will append a bit, \(b(n)\), onto the approximation at the end of each iteration.</p>
                    <div class="curly_block">{{#eqn.labeled}}2: $$\begin{array}{rcl} approx (0) &amp;=&amp; 0 \\ \\ approx (n + 1) &amp;=&amp; approx (n) + \frac{b (n)}{2^n}\end{array}$${{/eqn.labeled}}</div>
                    <p>where:</p>
                    <div class="curly_block">{{#eqn.labeled}}4: $$b(n) = \begin{cases} 1, &amp; \mbox{if } \frac{1}{2^n} (2\ approx (n) + \frac{1}{2^n}) \le error (n) \\ \\ 0, &amp; \mbox{otherwise}\end{cases}$${{/eqn.labeled}}</div>
                    <p>Using back substitution we can solve for \(error\) to derive the following recurrence relation:</p>
                    <div class="curly_block">{{#eqn.labeled}}5: $$\begin{array}{rcl} error (0) &amp;=&amp; x \\ \\ error (n + 1) &amp;=&amp; error (n) - \frac{b (n)}{2^n} (2\ approx (n) + \frac{b (n)}{2^n})\end{array}$${{/eqn.labeled}}</div>
                    <p>Using the above equations and the fact that \(1 &lt;= x &lt; 2\), we can derive the following corollaries:</p>
                    <div class="curly_block">{{#eqn.labeled}}6: $$\forall n, 0 \le approx(n) \lt 2$${{/eqn.labeled}}</div>
                    <div class="curly_block">
                      {{#eqn.labeled}}7: $$\begin{array}{rcl} \forall n, b (n) = 0 \implies error (n) \lt \frac{1}{2^n} (2\ approx (n) + \frac{1}{2^n}) \\ \\ \forall n, b (n) = 1 \implies \frac{1}{2^n} (2\ approx (n) + \frac{1}{2^n}) \le error (n) \end{array}$${{/eqn.labeled}}
                    </div>
                  </div>
                </div>
                <div class="accordion_item_block">
                  <div class="accordion_item_number">3</div>
                  <div class="accordion_item_title">A Lower Bound for \(approx\)</div>
                  <div class="accordion_item_body">
                    <p>Next we establish a lower bound constraint for \(approx(n)\):</p>
                    <div class="eqn-labeled">
                      $$\mbox{Lemma 1.1:}\quad \forall n, x \lt (approx (n) + \frac{2}{2^n})^2$$
                    </div>
                    <p><strong>Proof</strong></p>
                    <p>We proceed using a proof by induction. When n = 0, substitution gives:</p>
                    <div class="curly_block">{{#eqn.labeled}}8: $$\begin{array}{rcl} x &amp;\lt&amp; (approx (0) + \frac{2}{2^0})^2 \\ x &amp;\lt&amp; 4\end{array}$${{/eqn.labeled}}</div>
                    <p>When \(n \gt 0\), we have to prove:</p>
                    <div class="curly_block">{{#eqn.labeled}}9: $$\begin{array}{l} \forall n, &amp;x \lt (approx (n) + \frac{2}{2^n})^2 \implies \\ &amp;x \lt (approx (n + 1) + \frac{1}{2^n})^2.\end{array}$${{/eqn.labeled}}</div>
                    <p>We proceed by case analysis. \(b (n)\) equals either 0 or 1.</p>
                    <p><strong><code>b (n) = 0</code></strong><p>
                    <p>When \(b (n) = 0\), our goal becomes: \(x \lt (approx (n) + \frac{1}{2^n})^2\). Expanding and rewriting \(error\) using (7) leads to:</p>
                    <div class="eqn-labeled">
                      $$\begin{array}{rcl}<!--
                        -->x &amp;=&amp; approx (n)^2 + error (n) \\<!--
                        -->x &amp;\lt&amp; approx (n)^2 + \frac{1}{2^n} (2\ approx (n) + \frac{1}{2^n}) \quad \quad \mbox{by (7)} \\<!--
                        -->x &amp;\lt&amp; (approx (n) + \frac{1}{2^n})^2<!--
                      -->\end{array}$$
                    </div>
                    <p><strong><code>b (n) = 1</code></strong><p>
                    <p>
                      When \(b (n) = 1\), our goal becomes: \(x \lt (approx (n) + \frac{1}{2^n} + \frac{1}{2^n})^2\).
                      However, this is equivalent to: \(a \lt (approx (n) + \frac{2}{2^n})^2\), which is identical to our inductive hypothesis.
                      &#8718;
                    </p>
                  </div>
                </div>
                <div class="accordion_item_block">
                  <div class="accordion_item_number">4</div>
                  <div class="accordion_item_title">A Constant Upper Bound for \(error\)</div>
                  <div class="accordion_item_body">
                    <p>The following lemma establishes an upper bound for \(error (n)\) that we will need to prove our primary theorem below.</p>
                    <div class="eqn-labeled">
                      $$\mbox{Lemma 1.2:}\quad \forall n, error (n) \lt 4$$
                    </div>
                    <p><strong>Proof</strong></p>
                    <p>We proceed using proof by induction.</p>
                    <p><strong><code>n = 0</code></strong><p>
                    <p>When \(n = 0\), the lemma follows immediately from (5): \(error (0) = x \lt 2\).</p>
                    <p><strong><code>n &ge; 1</code></strong><p>
                    <p>
                      When \(n \ge 1\), our goal becomes: \(error (n) \lt 4 \implies error (n + 1) \lt 4\).
                      Assuming that \(error (n) \lt 4\) and expanding \(error (n + 1)\) leads to:
                    </p>
                    <div class="eqn-labeled">
                      $$\begin{array}{rcl}<!--
                        -->error (n + 1) &amp;=&amp; error (n) - \frac{b (n)}{2^n} (2\ approx (n) + \frac{b (n)}{2^n}) \\<!--
                        -->error (n + 1) &amp;\lt&amp; 4 - \frac{b (n)}{2^n} (2\ approx (n) + \frac{b (n)}{2^n}) \qquad \mbox{by the ind. hyp.} \\<!--
                        -->error (n + 1) &amp;\lt&amp; 4 - 0 \\<!--
                      -->\end{array}$$
                    </div>
                    <p>
                      Where we maximized the rhs in the last inequality by taking the case where \(b (n) = 0\).  
                      &#8718;
                    </p>
                  </div>
                </div>
                <div class="accordion_item_block">
                  <div class="accordion_item_number">5</div>
                  <div class="accordion_item_title">A Scaling Upper Bound for \(error\)</div>
                  <div class="accordion_item_body">
                    <div class="eqn-labeled">
                      $$\mbox{Lemma 1.3:}\quad \forall n, x \lt (approx (n) + \frac{2}{2^n})^2$$
                    </div>
                    <p><strong>Proof</strong></p>
                    <p>
                      We will proceed by induction over \(n\).
                      When \(n = 0\), Lemma 1.3 follows immediately as \((approx (0) + \frac{2}{2^0})^2 = 4\) and \(x \lt 2\).
                      When \(n \ge 1\), our goal becomes: \(x \lt (approx (n) + \frac{2}{2^n})^2 \implies x \lt (approx (n + 1) + \frac {2}{2^{n + 1}})^2\).
                      Unfolding \(approx (n + 1)\), reduces our goal to: \(x \lt (approx (n) + \frac{b (n)}{2^n} + \frac{1}{2^n})^2\).
                    </p>
                    <p><strong><code>b (n) = 0</code></strong><p>
                    <p>When \(b (n) = 0\) our goal follows algebraicly:</p>
                    <div class="eqn-labeled">
                      $$\begin{array}{rcl}<!--
                        -->x &amp;=&amp; approx (n)^2 + error (n)\\<!--
                        -->&amp;\lt&amp; approx (n)^2 + \frac{1}{2^n} (2\ approx (n) + \frac{1}{2^n}) \qquad \mbox {by (7)}\\<!--
                        -->&amp;\lt&amp; (approx (n) + \frac{1}{2^n})^2\\<!--
                      -->\end{array}$$
                    </div>
                    <p><strong><code>b (n) = 1</code></strong><p>
                    <p> 
                      When \(b (n) = 1\) our goal equals the inductive hypothesis.
                      &#8718;
                    </p>
                    <hr/>
                    <div class="eqn-labeled">
                      $$\mbox{Corollary 1.4:}\quad \forall n, error (n) \lt \frac{4}{2^n} (approx (n) + \frac{1}{2^n})$$
                    </div>
                    <p><strong>Derivation</strong></p>
                    <p>Corollary 1.4 follows algebraicly from Lemma 1.3:</p>
                    <div class="eqn-labeled">
                      $$\begin{array}{rcl}<!--
                        -->x &amp;\lt&amp; (approx (n) + \frac{2}{2^n})^2 \\<!--
                        -->x &amp;\lt&amp; approx (n)^2 + \frac{4}{2^n} (approx (n) + \frac{1}{2^n}) \\<!--
                        -->x - approx (n)^2 &amp;\lt&amp; \frac{4}{2^n} (approx (n) + \frac{1}{2^n}) \\<!--
                        -->error (n) &amp;\lt&amp; \frac{4}{2^n} (approx (n) + \frac{1}{2^n})<!--
                      -->\end{array}$$
                    </div>
                  </div>
                </div>
                <div class="accordion_item_block">
                  <div class="accordion_item_number">6</div>
                  <div class="accordion_item_title">Conclusion</div>
                  <div class="accordion_item_body">
                    <p>We are now in a position to prove the main result:</p>
                    <div class="eqn-labeled">
                      $$\mbox{Theorem 1.5:}\quad \forall n, error (n) \lt \frac{8}{2^n}$$
                    </div>
                    <p><strong>Proof</strong></p>
                    <p>
                      We will proceed using induction over \(n\).
                      When \(n = 0\), \(error (0) = x \lt 2\) and Theorem 1.5 follows immediately.
                      Hence, we only need to consider the case where \(n \ge 1\).
                    </p>
                    <p>Observe that:</p>
                    <div class="eqn-labeled">
                      $$\begin{array}{rcl}<!--
                        -->approx (n)^2 &amp;=&amp; x - error (n) \\<!--
                        -->approx (n)^2 &amp;\lt&amp; 2 - 0 \qquad \mbox{using (6)} \\<!--
                        -->approx (n) &amp;\lt&amp; \sqrt {2}<!--
                      -->\end{array}$$
                    </div>
                    <p>
                      We can substitute this upper bound into the scaling upper bound we derived in Corollary 1.4.
                      Doing so leads to:
                    </p>
                    <div class="eqn-labeled">
                      $$\begin{array}{rcl}<!--
                        -->error (n) &amp;\lt&amp; \frac{4}{2^n} (approx (n) + \frac{1}{2^n}) \\<!--
                        -->error (n) &amp;\lt&amp; \frac{4}{2^n} (\sqrt {2} + \frac{1}{2^n})<!--
                      -->\end{array}$$
                    </div>
                    <p>
                      which is always less than \(\frac{8}{2^n}\) when \(n \ge 1\).
                      This observation completes this proof.
                      &#8718;
                    </p>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        <!-- portfolio -->
        <div id='portfolio' class='section'>
          <div class='section-content'>
            <div class='section-header'>
              <h1>Portfolio: Large Scale Developments Using Coq</h1>
            </div>
            <div class='section-body'>
              <p>While working with SiFive, I was the lead developer for the Kami Processor, an Open-Source Risc-v processor written in Kami.</p>
              <p>Kami is a domain-specific language designed for modeling digital circuits.</p>
              <p>The Kami processor is a highly configurable RISC-V processor that implements a substantial fraction of the RISC-V feature set: including memory virtualization, compressed instruction encodings, floating point operations, and dynamic data widths.</p>
              <p>Kami is embedded within Gallina, Coq's dependently-typed programming language. Using Coq, I've verified components used within the Kami Processor and verified the Gallina functions used to generate the Kami Processor model.</p>
            </div>
          </div>
        </div>
        <!-- sample work -->
        <div id='samples' class='section'>
          <div class='section-content'>
            <div class='section-header'>
              <h1>Code Samples: Demonstrations of my ability to write formally verified algorithms</h1>
            </div>
            <div class='section-body'>
              <p>While working with SiFive, I was the lead developer for the Kami Processor, an Open-Source Risc-v processor written in Kami.</p>
              <p>Kami is a domain-specific language designed for modeling digital circuits.</p>
              <p>The Kami processor is a highly configurable RISC-V processor that implements a substantial fraction of the RISC-V feature set: including memory virtualization, compressed instruction encodings, floating point operations, and dynamic data widths.</p>
              <p>Kami is embedded within Gallina, Coq's dependently-typed programming language. Using Coq, I've verified components used within the Kami Processor and verified the Gallina functions used to generate the Kami Processor model.</p>
              <div class='coq_block'>modules/coq/examples/nat_str.v</div>
            </div>
          </div>
        </div>
        <!-- open source contributions -->
        <div id='contributions' class='section'>
          <div class='section-content'>
            <div class='section-header'>
              <h1>Open Source Contributions</h1>
            </div>
            <div class='section-body'>
              <p>Over the years, I've contributed to the Coq Standard Library and released packages through the Coq Package Index.</p>
              <p>The Coq package index is a curated collection of Coq modules that are released by the Coq maintainers as part of the Coq cpan repository.</p>
              <p>I am the package maintainer for two CPI libraries: functional algebra and pigeons.</p>
            </div>
          </div>
        </div>
        <!-- contact -->
        <div id='contact' class='dark-section section'>
          <div class='section-content'>
            <div class='section-header'>
              <h1>Want to know more?</h1>
              <ul>
                <li><span class='contact-label'>email:</span><a href="mailto:llee454@gmail.com">llee454@gmail.com</a></li>
                <li><span class='contact-label'>github:</span><a href="https://github.com/llee454">https://github.com/llee454</a></li>
              </ul>
            </div>
            <div class='section-body'>
              <div class="form_block">feedback_form</div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div id="back_to_top"><a href="#">Back To Top</a></div>
    <div id="footer"></div>
  </body>
</html>
