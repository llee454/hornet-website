<!DOCTYPE html>
<!-- set mustache tag delimiters  -->
<html lang="en">
  <head>
    <title>Larry Lee: Programmer</title>
    <meta name="viewport" content="initial-scale = 1.0,maximum-scale = 1.0" http-equiv="Content-Type">
    <link rel="icon" type="image/png" href="images/favicon.png">

    <!-- Import Libraries -->
    <script src="lib/async/dist/async.js"></script>
    <script src="lib/jquery/jquery.js"></script>
    <script src="lib/jquery-getCSS/jquery.getCSS.js"></script>
    <script src="lib/jquery-ui/jquery-ui.js"></script>
    <script src="lib/jq-ajax-progress/src/jq-ajax-progress.js"></script>
    <script src="lib/uri/uri.js"></script> 
    <script src="lib/qunit/qunit.js"></script>
    <script>
      QUnit.config.autostart = false;
    </script>
 
    <!-- Load the library stylesheets -->
    <link rel="stylesheet" type="text/css" href="lib/jquery-ui/jquery-ui.min.css">

     <!-- Load the current theme's stylesheet -->
    <link rel="stylesheet" type="text/css" href="themes/portfolio/portfolio.css">

    <!-- Load the module libraries -->
    <script src="modules/coq/lib/node_modules/jscoq/ui-js/jscoq-loader.js"></script>

    <!-- Load the experimental Progressbar module -->                                                |~                                                                                                        
    <script src="modules/progressbar/progressbar.js"></script>

    <!-- Load the Core Module -->
    <script src="modules/core/core.js"></script>
  </head>
  <body id="top">
    <div id='header'>
      <div id='header-content'>
        <div id='header-menu-container'>
          <div id='header-menu'>
            <a class='menu-item header-menu-item' href='##case-study'>CASE STUDY</a>
            <a class='menu-item header-menu-item' href='##samples'>WORK SAMPLES</a>
            <a class='menu-item header-menu-item' href='data/resume with cover letter.pdf'>RESUME</a>
            <a class='menu-item header-menu-item' href='##endorsements'>REFERENCES</a>
            <a class='menu-item header-menu-item' href='##contact'>CONTACT</a>
          </div>
        </div>
      </div>
    </div>
    <div id='mobile-menu'>
      <div id='mobile-menu-header'>MENU</div>
      <div id='mobile-menu-content'>
        <a class='menu-item mobile-menu-item' href='##case-study'>CASE STUDY</a>
        <a class='menu-item mobile-menu-item' href='##samples'>WORK SAMPLES</a>
        <a class='menu-item mobile-menu-item' href='data/resume with cover letter.pdf'>RESUME</a>
        <a class='menu-item mobile-menu-item' href='##endorsements'>REFERENCES</a>
        <a class='menu-item mobile-menu-item' href='##contact'>CONTACT</a>
      </div>
    </div>
    <div id='hero'>
      <div id='hero-overlay'>
        <div id='hero-overlay-content'>
          <h1>Proven Ability &#8718;</h1>
          <p>
            My name is <strong>Larry Lee</strong> and I am a software developer specializing in formal methods.
            My work includes formally verified hardware designs and real-world examples of applied mathematics.
          </p>
        </div>
      </div>
      <div id='hero-video-container'>
        <video id='hero-video' class="video-js vjs-default-skin" muted loop autoplay preload="auto">
          <source src="https://work-website-media.s3.us-east-2.amazonaws.com/background+loop.mp4"/>
        </video>
      </div>
    </div>
    <div id='body'>
      <div id='main-content'>
        <!-- intro section -->
        <div id='intro' class='section light-section'>
          <div class='section-content'>
            <div id='assertion' class='section-header'>
              <h1><span class='section-start-icon'>&#8718;</span><br/>I am a software developer specializing in formal methods.</h1>
            </div>
            <div class='section-body'>
              <p>
                Formally Verified Software development is the practice of writing mathematical proofs to verify software.
                I specialize in using <strong>Coq</strong> to do this.
                Over the last 7 years, I've written <strong>hundreds</strong> of proofs using Coq and have developed formally verified algorithms.
                I've contributed to the Coq Standard Library and am a package maintainer in the Coq Package Index.
                My portfolio demonstrates my ability to analyze complex problems and produce results.
              </p>
              <div class="video_player_block">
                <video id="intro-video" class="video-js vjs-default-skin" poster="images/hero_video_poster.jpeg" controls preload="auto">
                  <source src="https://work-website-media.s3.us-east-2.amazonaws.com/success+story+second+version.mp4"/>
                </video>
              </div>
            </div>
          </div>
        </div>
        <!-- success story -->
        <div id='case-study' class='section light-section'>
          <div class='section-content'>
            <div class='section-header'>
              <h1><span class='section-start-icon'>&#8718;</span><br/>Industrial Results</h1>
            </div>
            <div class='section-body'>
              <p>SiFive is a Silicon Valley-based company specializing in the design of RISC-V processors.</p>
              <p>
                In 2018, they suspected that a register used within the floating point unit of their S-series processors was too small to store the intermediate values that it computed during square root and division operations.
                While the unit passed SiFive's test suite, They feared that a bug lurked in an edge case not covered by their tests.
              </p>
              <p>
                I successfully derived an analytical proof verifying that the registers allocated by the unit where sufficiently large to store these intermediate values.
                More importantly, I formalized this proof using Coq; thereby giving SiFive the assurance that they needed to move forward with production.
              </p>
              <p>
                Click on the down arrows below to view an excerpt from this proof. You can view the full proof here: <a href="https://github.com/llee454/FPU-Verification">FPU-Verification</a>
              </p>
              <div id='case-study-details' class="accordion_block">
                <div class="accordion_item_block">
                  <div class="accordion_item_number">1</div>
                  <div class="accordion_item_title">Introduction</div>
                  <div class="accordion_item_body">
                    <p>
                      SiFive developed the floating point unit in a modeling language named Chisel.
                      I began by writing a set of recurrence relations that formalized the square root and division algorithms.
                      I then identified bijective mappings between the variables used in SiFive's model and the variables used in my equations.
                      This allowed me to prove that my equations correctly modeled the unit.
                      Then, I verified that my equations correctly converged onto the correct results, thereby verifying that SiFive's unit was logically correct.
                    </p>
                    <p>
                      One problem remained however.
                      SiFive's unit defined a register named \(rem\), and they feared that this register was too small to store all of the intermediate values computed during operation.
                      To prove that the \(rem\) register was large enough, I needed to prove that the values stored within \(rem\) were smaller than \(2^w\), where \(w\) represented the number of bits SiFive had allocated.
                    </p>
                    <p>
                      This register corresponded to a variable defined within my equations named \(error(n)\).
                      Using the mapping between \(rem\) and \(error(n)\), I had to verify that: $$\forall n, error(n) &lt; \frac{8}{2^n}$$ when computing the square root of an odd number, and an analogous result when computing the square root of even numbers.
                      The following is an extract of my proof of this result.
                    </p>
                  </div>
                </div>
                <div class="accordion_item_block">
                  <div class="accordion_item_number">2</div>
                  <div class="accordion_item_title">The Model</div>
                  <div class="accordion_item_body">
                    <p>
                      Let \(x\) denote the number that the floating point unit is computing the square root for.
                      Let \(approx(n)\) denote the \(n^{th}\) approximation of the square root of \(x\).
                      And, let \(error(n)\) represent the \(n^{th}\) approximation error.
                      Then \(x\) is given by:
                    </p>
                    <div class="eqn-labeled"><table><tbody><tr><td class="eqn">$$x = approx (n)^2 + error (n)$$</td><td class="eqn-label">1</td></tr></tbody></table></div>
                    <p>Setting \(approx(0) = 0\), we will append a bit, \(b(n)\), onto the approximation at the end of each iteration.</p>
                    <div class="eqn-labeled"><table><tbody><tr><td class="eqn">$$\begin{array}{rcl} approx (0) &amp;=&amp; 0 \\ \\ approx (n + 1) &amp;=&amp; approx (n) + \frac{b (n)}{2^n}\end{array}$$</td><td class="eqn-label">2</td></tr></tbody></table></div>
                    <p>where:</p>
                    <div class="eqn-labeled"><table><tbody><tr><td class="eqn">$$b(n) = \begin{cases} 1, &amp; \mbox{if } \frac{1}{2^n} (2\ approx (n) + \frac{1}{2^n}) \le error (n) \\ \\ 0, &amp; \mbox{otherwise}\end{cases}$$</td><td class="eqn-label">4</td></tr></tbody></table></div>
                    <p>Using back substitution we can solve for \(error\) to derive the following recurrence relation:</p>
                    <div class="eqn-labeled"><table><tbody><tr><td class="eqn">$$\begin{array}{rcl} error (0) &amp;=&amp; x \\ \\ error (n + 1) &amp;=&amp; error (n) - \frac{b (n)}{2^n} (2\ approx (n) + \frac{b (n)}{2^n})\end{array}$$</td><td class="eqn-label">5</td></tr></tbody></table></div>
                    <p>Using the above equations and the fact that \(1 &lt;= x &lt; 2\), we can derive the following corollaries:</p>
                    <div class="eqn-labeled"><table><tbody><tr><td class="eqn">$$\forall n, 0 \le approx(n) \lt 2$$</td><td class="eqn-label">6</td></tr></tbody></table></div>
                    <div class="eqn-labeled"><table><tbody><tr><td class="eqn">$$\begin{array}{rcl} \forall n, b (n) = 0 \implies error (n) \lt \frac{1}{2^n} (2\ approx (n) + \frac{1}{2^n}) \\ \\ \forall n, b (n) = 1 \implies \frac{1}{2^n} (2\ approx (n) + \frac{1}{2^n}) \le error (n) \end{array}$$</td><td class="eqn-label">7</td></tr></tbody></table></div>
                  </div>
                </div>
                <div class="accordion_item_block">
                  <div class="accordion_item_number">3</div>
                  <div class="accordion_item_title">A Lower Bound for \(approx\)</div>
                  <div class="accordion_item_body">
                    <div class="eqn-labeled">
                      $$\mbox{Lemma 1.1:}\quad \forall n, x \lt (approx (n) + \frac{2}{2^n})^2$$
                    </div>
                    <p><strong>Proof</strong></p>
                    <p>We proceed using a proof by induction. When n = 0, substitution gives:</p>
                    <div class="eqn-labeled"><table><tbody><tr><td class="eqn">$$\begin{array}{rcl} x &amp;\lt&amp; (approx (0) + \frac{2}{2^0})^2 \\ x &amp;\lt&amp; 4\end{array}$$</td><td class="eqn-label">8</td></tr></tbody></table></div>
                    <p>When \(n \gt 0\), we have to prove:</p>
                    <div class="eqn-labeled"><table><tbody><tr><td class="eqn">$$\begin{array}{l} \forall n, &amp;x \lt (approx (n) + \frac{2}{2^n})^2 \implies \\ &amp;x \lt (approx (n + 1) + \frac{1}{2^n})^2.\end{array}$$</td><td class="eqn-label">9</td></tr></tbody></table></div>
                    <p>We proceed by case analysis. \(b (n)\) equals either 0 or 1.</p>
                    <p><strong><code>b (n) = 0</code></strong><p>
                    <p>When \(b (n) = 0\), our goal becomes: \(x \lt (approx (n) + \frac{1}{2^n})^2\). Expanding and rewriting \(error\) using (7) leads to:</p>
                    <div class="eqn-labeled">
                      $$\begin{array}{rcl}<!--
                        -->x &amp;=&amp; approx (n)^2 + error (n) \\<!--
                        -->x &amp;\lt&amp; approx (n)^2 + \frac{1}{2^n} (2\ approx (n) + \frac{1}{2^n}) \quad \quad \mbox{by (7)} \\<!--
                        -->x &amp;\lt&amp; (approx (n) + \frac{1}{2^n})^2<!--
                      -->\end{array}$$
                    </div>
                    <p><strong><code>b (n) = 1</code></strong><p>
                    <p>
                      When \(b (n) = 1\), our goal becomes: \(x \lt (approx (n) + \frac{1}{2^n} + \frac{1}{2^n})^2\).
                      However, this is equivalent to: \(a \lt (approx (n) + \frac{2}{2^n})^2\), which is identical to our inductive hypothesis.
                      &#8718;
                    </p>
                  </div>
                </div>
                <div class="accordion_item_block">
                  <div class="accordion_item_number">4</div>
                  <div class="accordion_item_title">A Constant Upper Bound for \(error\)</div>
                  <div class="accordion_item_body">
                    <div class="eqn-labeled">
                      $$\mbox{Lemma 1.2:}\quad \forall n, error (n) \lt 4$$
                    </div>
                    <p><strong>Proof</strong></p>
                    <p>We proceed using proof by induction.</p>
                    <p><strong><code>n = 0</code></strong><p>
                    <p>When \(n = 0\), the lemma follows immediately from (5): \(error (0) = x \lt 2\).</p>
                    <p><strong><code>n &ge; 1</code></strong><p>
                    <p>
                      When \(n \ge 1\), our goal becomes: \(error (n) \lt 4 \implies\)\(error (n + 1) \lt 4\).
                      Assuming that \(error (n) \lt 4\) and expanding \(error (n + 1)\) leads to:
                    </p>
                    <div class="eqn-labeled">
                      $$\begin{array}{rcl}<!--
                        -->error (n + 1) &amp;=&amp; error (n) - \frac{b (n)}{2^n} (2\ approx (n) + \frac{b (n)}{2^n}) \\<!--
                        -->error (n + 1) &amp;\lt&amp; 4 - \frac{b (n)}{2^n} (2\ approx (n) + \frac{b (n)}{2^n}) \qquad \mbox{by the ind. hyp.} \\<!--
                        -->error (n + 1) &amp;\lt&amp; 4 - 0 \\<!--
                      -->\end{array}$$
                    </div>
                    <p>
                      Where we maximized the rhs in the last inequality by taking the case where \(b (n) = 0\).  
                      &#8718;
                    </p>
                  </div>
                </div>
                <div class="accordion_item_block">
                  <div class="accordion_item_number">5</div>
                  <div class="accordion_item_title">A Scaling Upper Bound for \(error\)</div>
                  <div class="accordion_item_body">
                    <div class="eqn-labeled">
                      $$\mbox{Lemma 1.3:}\quad \forall n, x \lt (approx (n) + \frac{2}{2^n})^2$$
                    </div>
                    <p><strong>Proof</strong></p>
                    <p>
                      We will proceed by induction over \(n\).
                      When \(n = 0\), Lemma 1.3 follows immediately as \((approx (0) + \frac{2}{2^0})^2 = 4\) and \(x \lt 2\).
                      When \(n \ge 1\), our goal becomes: \(x \lt (approx (n) + \frac{2}{2^n})^2 \implies\)\(x \lt (approx (n + 1) + \frac {2}{2^{n + 1}})^2\).
                      Unfolding \(approx (n + 1)\), reduces our goal to: \(x \lt (approx (n) + \frac{b (n)}{2^n} + \frac{1}{2^n})^2\).
                    </p>
                    <p><strong><code>b (n) = 0</code></strong><p>
                    <p>When \(b (n) = 0\) our goal follows algebraically:</p>
                    <div class="eqn-labeled">
                      $$\begin{array}{rcl}<!--
                        -->x &amp;=&amp; approx (n)^2 + error (n)\\<!--
                        -->&amp;\lt&amp; approx (n)^2 + \frac{1}{2^n} (2\ approx (n) + \frac{1}{2^n}) \qquad \mbox {by (7)}\\<!--
                        -->&amp;\lt&amp; (approx (n) + \frac{1}{2^n})^2\\<!--
                      -->\end{array}$$
                    </div>
                    <p><strong><code>b (n) = 1</code></strong><p>
                    <p> 
                      When \(b (n) = 1\) our goal equals the inductive hypothesis.
                      &#8718;
                    </p>
                    <hr/>
                    <div class="eqn-labeled">
                      $$\mbox{Corollary 1.4:}\quad \forall n, error (n) \lt \frac{4}{2^n} (approx (n) + \frac{1}{2^n})$$
                    </div>
                    <p><strong>Derivation</strong></p>
                    <p>Corollary 1.4 follows algebraically from Lemma 1.3:</p>
                    <div class="eqn-labeled">
                      $$\begin{array}{rcl}<!--
                        -->x &amp;\lt&amp; (approx (n) + \frac{2}{2^n})^2 \\<!--
                        -->x &amp;\lt&amp; approx (n)^2 + \frac{4}{2^n} (approx (n) + \frac{1}{2^n}) \\<!--
                        -->x - approx (n)^2 &amp;\lt&amp; \frac{4}{2^n} (approx (n) + \frac{1}{2^n}) \\<!--
                        -->error (n) &amp;\lt&amp; \frac{4}{2^n} (approx (n) + \frac{1}{2^n})<!--
                      -->\end{array}$$
                    </div>
                  </div>
                </div>
                <div class="accordion_item_block">
                  <div class="accordion_item_number">6</div>
                  <div class="accordion_item_title">Conclusion</div>
                  <div class="accordion_item_body">
                    <div class="eqn-labeled">
                      $$\mbox{Theorem 1.5:}\quad \forall n, error (n) \lt \frac{8}{2^n}$$
                    </div>
                    <p><strong>Proof</strong></p>
                    <p>
                      We will proceed using induction over \(n\).
                      When \(n = 0\), \(error (0) = x \lt 2\) and Theorem 1.5 follows immediately.
                      Hence, we only need to consider the case where \(n \ge 1\).
                    </p>
                    <p>Observe that:</p>
                    <div class="eqn-labeled">
                      $$\begin{array}{rcl}<!--
                        -->approx (n)^2 &amp;=&amp; x - error (n) \\<!--
                        -->approx (n)^2 &amp;\lt&amp; 2 - 0 \qquad \mbox{using (6)} \\<!--
                        -->approx (n) &amp;\lt&amp; \sqrt {2}<!--
                      -->\end{array}$$
                    </div>
                    <p>
                      We can substitute this upper bound into the scaling upper bound we derived in Corollary 1.4.
                      Doing so leads to:
                    </p>
                    <div class="eqn-labeled">
                      $$\begin{array}{rcl}<!--
                        -->error (n) &amp;\lt&amp; \frac{4}{2^n} (approx (n) + \frac{1}{2^n}) \\<!--
                        -->error (n) &amp;\lt&amp; \frac{4}{2^n} (\sqrt {2} + \frac{1}{2^n})<!--
                      -->\end{array}$$
                    </div>
                    <p>
                      which is always less than \(\frac{8}{2^n}\) when \(n \ge 1\).
                      This observation completes this proof.
                      &#8718;
                    </p>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        <!-- portfolio -->
        <div id='portfolio' class='section dark-section'>
          <div id='portfolio-parallax-background'></div>
          <div id='portfolio-parallax-background-overlay'></div>
          <div class='section-content-padding'>
            <div class='section-content'>
              <div class='section-header'>
                <h1><span class='section-start-icon'>&#8718;</span><br/>Large Scale Developments</h1>
              </div>
              <div class='section-body'>
                <p>While working at SiFive, I was the lead developer for Kami Processor, an Open-Source RISC-V processor written in the modeling language Kami.</p>
                <p>Kami Processor is highly configurable and implements a substantial fraction of the RISC-V feature set: including memory virtualization, compressed instruction encodings, floating point operations, and dynamic data widths.</p>
                <p>I developed and verified most of the Gallina functions used to generate Kami Processor and contributed proofs to the Kami language project. Click on the down arrows below to read more about my work.</p>
                <div id='portfolio-details' class="accordion_block">
                  <div class="accordion_item_block">
                    <div class="accordion_item_number">1</div>
                    <div class="accordion_item_title">Kami Processor</div>
                    <div class="accordion_item_body">
                      <h2>Overview</h2>
                      <p>SiFive started the Kami Processor project in 2018 intending to develop a canonical model of the RISC-V specification. While working at SiFive, I was the primary developer for Kami Processor.</p>
                      <p>The Kami processor supports the following RISC-V extensions: I, M, A, D, F, C, S, U, Zifencei, and Zcsr. This means that the Kami processor supports the mandatory core set of integer arithmetic and logic instructions prescribed by the RISC-V ISA (I). In addition, it supports integer multiplication (M), atomic memory operations (A), 64 bit floating point operations (D), 32 bit floating point operations (F), compressed instruction encodings (C), multi threaded synchronization support (ZiFencei), and support for RISC-V's control status register operations (Zicsr).</p>
                      <p>The Kami Processor includes a page table walker which allows applications to translate between physical and virtual memory addresses. Kami Processor includes a translation look-aside buffer that caches address translations in a buffer that uses a pseudo-LRU allocation algorithm.</p>
                      <p>The RISC-V spec defines several virtual memory modes. These are denoted by a code that indicates the size of the words used to encode virtual addresses. For example, "sv39" indicates that the virtual addresses are 39 bits wide. The Kami Processor supports virtual address modes sv32, sv39, and sv48.</p>
                      <p>The RISC-V memory protection model prescribes a physical memory protection scheme based around physical protection control status registers (PMP CSRs). The Kami Processor supports the full suite of PMP CSRs and all of the RISC-V address matching schemes, namely: top of range (TOR), naturally aligned four-byte regions (NA4), and naturally aligned power of two regions (NAPOT). Its address granularity is configurable.</p>
                      <p>I wrote the Kami Processor to use the TileLink interchip communication protocol. The TileLink protocol defines a set of conformance levels. Kami Processor's device interface communicates using the TileLink Uncached Heavyweight (TL-UH) message protocol. This protocol extends the basic read and write messages provided by the TileLink Uncached Lightweight (TL-UL) message protocol by adding atomic memory operations. By supporting the TileLink protocol, the Kami Processor can be integrated into systems using a number of interchip bus protocols either directly or through a conversion bridge.</p>
                      <p>Read the following report to learn more about the Kami Processor.</p>
                      <ul class='links'>
                        <li><a href='data/kami_proc_report.pdf'>Kami Processor: Status and Comparison</a></li>
                      </ul>
                    </div>
                  </div>
                  <div class="accordion_item_block">
                    <div class="accordion_item_number">2</div>
                    <div class="accordion_item_title">Kami</div>
                    <div class="accordion_item_body">
                      <h2>Overview</h2>
                      <p>Kami is a modeling language intended to model digital circuits. Its language syntax and semantics are derived from BlueSpec. It is a domain-specific language embedded withing Gallina, Coq's dependently typed programming language. Kami uses Gallina's dependent types to specify component properties. Kami verifies that these component properties are true using mathematical proofs expressed in Coq's Ltac and Gallina. Ltac is a macro language that Coq interprets to generate Gallina terms. These Gallina terms represent mathematical proofs.</p>
                      <P>A Kami model of a synchronous digital circuit consists of one or more Kami modules and a scheduler. A Kami module comprises a set of registers, rules, and methods. A rule represents a combinatorial circuit that the scheduler tries to execute as frequently as possible. A method is a combinatorial circuit that posses a well defined set of inputs and outputs and which may be shared between circuits provided by other modules. Both rules and methods consist of Kami actions. A Kami action is a combinatorial circuit that may read or write to one or more registers and which may "call" one or more methods. Kami actions consist of a series of Kami expressions, which are combinatorial circuits that do not write to registers or call methods, and Kami statements that read and write to registers and call methods.</p>
                      <h2>The Utila Library</h2>
                      <p>I wrote the Utila library, which defines a set of formally verified hardware components that are used throughout Kami Processor.</p>
                      <p>The library includes formally verified lookup tables, and useful circuit combinators.</p>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        <!-- sample work -->
        <div id='samples' class='section light-section'>
          <div class='section-content'>
            <div class='section-header'>
              <h1><span class='section-start-icon'>&#8718;</span><br/>Interactive Code Sample</h1>
            </div>
            <div class='section-body'>
              <p>
                The sample below presents three Gallina functions: <code>natToBinStr</code>, <code>natToDecStr</code>, and <code>natToHexStr</code>.
                Each of these functions accepts a number and returns a string that represents the given number in a specific format.
                In this example, I prove that these functions are injective.
              </p>
              <p>
                Whereas the print functions provided by the Coq Standard Library only support decimal and hexadecimal formats, the example presented below can support an arbitrary radix.
                Furthermore, this example demonstrates a number of Coq design patterns, including well founded recursion, structural recursion, and dependent types.
              </p>
              <p>
                This example was originally defined as part of the Kami project: <a href="https://github.com/sifive/Kami/blob/master/Lib/NatStr.v">NatStr.v</a>.
              </p>
              <div id='code-sample'>
                <div class='coq_block'>modules/coq/examples/nat_str.v</div>
              </div>
            </div>
          </div>
        </div>
        <!-- open source contributions -->
        <div id='contributions' class='section light-section'>
          <div class='section-content'>
            <div class='section-header'>
              <h1><span class='section-start-icon'>&#8718;</span><br/>Open Source Contributions</h1>
            </div>
            <div class='section-body'>
              <p>Over the years, I've contributed to the Coq Standard Library and released packages through the Coq Package Index.</p>
              <p>The Coq package index is a curated collection of Coq modules that are released by the Coq maintainers as part of the Coq Opam repository.</p>
              <p>I am the package maintainer for two CPI libraries: functional algebra and pigeons.</p>
              <ul class='links'>
                <li><a href='https://github.com/llee454/functional-algebra'>Functional Algebra: a formalization of abstract algebra</a></li>
                <li><a href='https://github.com/llee454/pigeons'>Pigeons: a sample proof of the Pigeonhole Principle</a></li>
              </ul>
            </div>
          </div>
        </div>
        <div id='endorsements' class='section light-section'>
          <div class='section-content'>
            <div class='section-header'>
              <h1><span class='section-start-icon'>&#8718;</span><br/>Endorsements</h1>
            </div>
            <div class='section-body'>
                <div class='endorsement'>
                  <div class='endorsement-quote'>
                    <p>"I was Larry&#39;s supervisor at SiFive. There, he was instrumental in bringing up a formal specification of the RISC-V processor in Kami, which is a framework in Coq to specify hardware circuits using transactional semantics. The task was pretty complex, given the enormity of the RISC-V specification and the ability to understand, Kami, a new framework completely, in order to write programs in that framework. Larry was a quick learner and was highly motivated to perform this task. He paid a lot of attention to detail and had excellent software engineering skills - always coming up with unit test cases even for the smallest change made or feature added to the code base. Overall, I enjoyed working with Larry."</p>
                  </div>
                  <div class='endorsement-author'>
                    <div class='endorsement-author-name'>Murali Vijayaraghavan</div>
                    <div class='endorsement-author-title'>Proof Engineer</div>
                    <div class='endorsement-author-email'>vmurali@csail.mit.edu</div>
                  </div>
                  <div class='clear-float'></div>
                </div>
                <div class='endorsement'>
                  <div class='endorsement-quote'>
                    <p>"Working with Larry for nearly two years at SiFive I have come to know him as a man with a efficient and effective proof writing technique. As evidenced by his work in the ProcKami repository, he also shows the great attention to detail and forward planning one associates with well-written COQ code."</p>
                  </div>
                  <div class='endorsement-author'>
                    <div class='endorsement-author-name'>Anthony Machado</div>
                    <div class='endorsement-author-title'>Proof Engineer</div>
                    <div class='endorsement-author-email'>tj.machado@gmail.com</div>
                  </div>
                  <div class='clear-float'></div>
                </div>
                <div class='endorsement'>
                  <div class='endorsement-quote'>
                    <p>"Larry Lee [has] great knowledge of theorem proving as well as the ProcKami [RISC-V] processor. He was always the one I talked to when I had a question on how something worked in the ProcKami processor or a question on the Kami language semantics. It was really enjoyable working with Larry Lee while I was at SiFive."</p>
                  </div>
                  <div class='endorsement-author'>
                    <div class='endorsement-author-name'>Kenneth Roe</div>
                    <div class='endorsement-author-title'>Proof Engineer</div>
                    <div class='endorsement-author-email'>http:&#x2F;&#x2F;www.cs.jhu.edu&#x2F;~roe&#x2F;</div>
                  </div>
                  <div class='clear-float'></div>
                </div>
            </div>
          </div>
        </div>
        <div id='qed-section' class='section light-section'>
          <div class='section-content'>
            <div class='section-body'>
              <div id='qed'><strong>\(\mbox {Q.E.D}\)</strong></div>
            </div>
          </div>
        </div>
        <!-- contact -->
        <div id='contact' class='dark-section section'>
          <div class='section-content'>
            <div class='section-header'>
              <h1>Send Me a Message</h1>
            </div>
            <div class='section-body'>
              <ul>
                <li><span class='contact-label'>email:</span><a href="mailto:llee454@gmail.com">llee454@gmail.com</a></li>
                <li><span class='contact-label'>github:</span><a href="https://github.com/llee454">https://github.com/llee454</a></li>
              </ul>
              <div class="form_block">feedback_form</div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div id="back_to_top"><a href="#">Back To Top</a></div>
    <div id="footer"></div>
  </body>
</html>
